# 设计模式

设计模式是一套被反复使用、经过分类的、代码设计经验的总结。它主要解决面向对象软件设计中的重复性问题，提高系统架构的设计质量。

## 创建型模式（Creational Pattern）

| 模式               | 描述                                                                 |
|--------------------|----------------------------------------------------------------------|
| 单例模式 (Singleton) | 确保一个类只有一个实例，并提供全局访问点。                               |
| 工厂模式 (Factory)   | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。                     |
| 抽象工厂模式 (Abstract Factory) | 提供一个创建一系列相关或相互依赖对象的接口，无需指定具体类。              |
| 建造者模式 (Builder) | 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。  |
| 原型模式 (Prototype) | 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。             |

## 结构型模式（Structural Pattern）

| 模式                | 描述                                                                   |
|---------------------|------------------------------------------------------------------------|
| 适配器模式 (Adapter) | 将一个类的接口转换成客户希望的另外一个接口。                             |
| 桥接模式 (Bridge)    | 将抽象部分与它的实现部分分离，使它们都可以独立地变化。                    |
| 组合模式 (Composite) | 将对象组合成树形结构以表示“部分-整体”的层次结构。                        |
| 装饰器模式 (Decorator) | 动态地给一个对象添加一些额外的职责。                                     |
| 外观模式 (Facade)    | 为子系统中的一组接口提供一个一致的界面。                                 |
| 享元模式 (Flyweight) | 运用共享技术有效地支持大量细粒度的对象。                                 |
| 代理模式 (Proxy)     | 为其他对象提供一种代理以控制对这个对象的访问。                            |

## 行为型模式（Behavioral Pattern）

| 模式                 | 描述                                                                       |
|----------------------|----------------------------------------------------------------------------|
| 模板方法模式 (Template Method) | 定义了一个算法的骨架，将某些步骤延迟到子类中实现。                           |
| 策略模式 (Strategy)   | 定义了一系列算法，将每个算法都封装起来，并使它们可以相互替换。                |
| 命令模式 (Command)    | 将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。            |
| 责任链模式 (Chain of Responsibility) | 将请求的发送者和接收者解耦，并沿着处理链传递请求。                          |
| 状态模式 (State)      | 允许对象在其内部状态改变时改变它的行为。                                     |
| 观察者模式 (Observer) | 定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会被通知。|
| 中介者模式 (Mediator) | 用一个中介对象来封装一系列对象之间的交互。                                   |
| 访问者模式 (Visitor)  | 定义了一种新的操作，可以在不改变对象结构的情况下向对象中添加新的操作。         |
| 迭代器模式 (Iterator) | 提供一种方法来访问一个容器对象中的各个元素，而不暴露该对象的内部细节。        |
| 备忘录模式 (Memento)  | 在不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态。     |